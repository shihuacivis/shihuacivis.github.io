<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 初识arrayBuffer和typeArray · shihuacivis' life</title><meta name="description" content="之前很少接触到这么冷门的知识点，直到最近有一个项目，需要前端通过websocket与服务端连接，服务端直接向前端发二进制的数据包，我才知道js还有这么arrayBuffer和typeArray这两货。我们可以用他们来解析服务端发来的二进制包。

知识回顾本来以为从事前端就再也不会接触进制、字节等这些晦涩的概念。
没想到苍天饶过谁……
二进制包的相关概念一般服务端会事先跟我们约定好发来的二进制包的格式，我们称之为协议
首先，一般一条二进制包数据会包含多个字节，光凭字节串我们是不能解析出里面的数据含义的。
协议的作用在于约定了二进制包的数据格式。我们通过协议可以知道二进制串中，从第几个字节到第几个字节表示什么类型数据，从而得出其准确的值。
回归正题，我们先了解一下如何从websocket中读取二进制数据。
如何读取二进制数据二进制数据是不能直接像其它js的基本数据类型一样直接通过等号获得和显示的。&lt;/"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/utakata.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/author.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="http://weibo.com/shihuacivis" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="http://shihuacivis.lofter.com" target="_blank" class="nav-list-link">LOFTER</a></li><li class="nav-list-item"><a href="https://github.com/shihuacivis" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">初识arrayBuffer和typeArray</h1><div class="post-meta"><div class="post-time">Dec 21, 2015</div></div><div class="post-content"><p>之前很少接触到这么冷门的知识点，直到最近有一个项目，需要前端通过websocket与服务端连接，服务端直接向前端发二进制的数据包，我才知道js还有这么arrayBuffer和typeArray这两货。我们可以用他们来解析服务端发来的二进制包。</p>
<a id="more"></a>
<h2 id="知识回顾">知识回顾</h2><p>本来以为从事前端就再也不会接触进制、字节等这些晦涩的概念。</p>
<p>没想到苍天饶过谁……</p>
<h3 id="二进制包的相关概念">二进制包的相关概念</h3><p>一般服务端会事先跟我们约定好发来的二进制包的格式，我们称之为<code>协议</code></p>
<p>首先，一般一条二进制包数据会包含多个<code>字节</code>，光凭字节串我们是不能解析出里面的数据含义的。</p>
<p><strong>协议</strong>的作用在于约定了二进制包的数据格式。我们通过协议可以知道二进制串中，从第几个字节到第几个字节表示什么类型数据，从而得出其准确的值。</p>
<p>回归正题，我们先了解一下如何从websocket中读取二进制数据。</p>
<h2 id="如何读取二进制数据">如何读取二进制数据</h2><p><strong>二进制数据是不能直接像其它js的基本数据类型一样直接通过等号获得和显示的。</strong></p>
<p>我们需要用到<code>FileReader</code>对象的<code>readAsArrayBuffer</code>方法读出其中的所有字节并将其转换成js能读取的arrayBuffer数据对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = e.data;</span><br><span class="line">  blob = message;</span><br><span class="line">  <span class="keyword">var</span> fileReader     = <span class="keyword">new</span> FileReader();</span><br><span class="line">  fileReader.onload  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// this.result为读取到的二进制包内容</span></span><br><span class="line">      arrayBufferNew = <span class="keyword">this</span>.result;</span><br><span class="line">  &#125;;</span><br><span class="line">  fileReader.readAsArrayBuffer(blob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayBuffer会在内存中新建一块缓冲区域，用于装载原始的数据包，<br>我们可以理解成，它创建了一个缓冲数组，然后把原始数据包的每个<code>字节</code>的值单独存放于一个数组元素中，但这个数组并不能直接进行读取。<br>我们还需要新建一个<code>TypeArray</code>对象，来读取这个缓冲区域的数据。</p>
<p><code>TypeArray</code>包含下面几种类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:right">描述</th>
<th style="text-align:right">C语言中的等效类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:right">8-bit</td>
<td style="text-align:right">signed char</td>
</tr>
<tr>
<td>Uint8Array</td>
<td style="text-align:center">1</td>
<td style="text-align:right">8-bit</td>
<td style="text-align:right">unsigned char</td>
</tr>
<tr>
<td>Int16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:right">16-bit</td>
<td style="text-align:right">short</td>
</tr>
<tr>
<td>Uint16Array</td>
<td style="text-align:center">2</td>
<td style="text-align:right">16-bit</td>
<td style="text-align:right">unsigned short</td>
</tr>
<tr>
<td>Int32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:right">32-bit</td>
<td style="text-align:right">int</td>
</tr>
<tr>
<td>Uint32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:right">32-bit</td>
<td style="text-align:right">unsigned int</td>
</tr>
<tr>
<td>Float32Array</td>
<td style="text-align:center">4</td>
<td style="text-align:right">32-bit</td>
<td style="text-align:right">float</td>
</tr>
<tr>
<td>Float64Array</td>
<td style="text-align:center">8</td>
<td style="text-align:right">64-bit</td>
<td style="text-align:right">double</td>
</tr>
</tbody>
</table>
<p><strong>重点来了</strong></p>
<p>以一个例子为例,首先协议体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> id;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>
<p>当我们收到如下面这个字节包时:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01</span>  <span class="number">0x02</span>   <span class="number">0x03</span>   <span class="number">0x04</span>   <span class="number">0xFF</span>   <span class="number">0xDD</span>   <span class="number">0x4c</span> <span class="number">0x8f</span></span><br></pre></td></tr></table></figure>
<p>我们知道，一个字节占8位，那么我们可以用Uint8Array读取占1字节的数据，可以用Uint16Array读取占2字节的数据。</p>
<p>那么我们可以用Uint8Array来显示数据的每个字节的内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayBufferNew = <span class="keyword">this</span>.result;</span><br><span class="line">arr  = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arrayBufferNew);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></p>
<p>根据协议体，我们知道前2个字节即为flag（char型占2字节），第3-4个字节是id（short型占2字节），而后4个字节则为num（int型占4字节）。</p>
<p>那么读取数据的过程如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fileReader.onload  = <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">  arrayBufferNew = <span class="keyword">this</span>.result;</span><br><span class="line">   <span class="comment">// 从第1个字节索引开始读取1个Uint16Array（即16位，2字节）</span></span><br><span class="line">  cFlag  = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(arrayBufferNew, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 从第3个字节索引开始读取1个Uint16Array（即16位，2字节）</span></span><br><span class="line">  sID = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(arrayBufferNew, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 从第5个字节索引开始读取1个Uint32Array（即32位，4字节）</span></span><br><span class="line">  nNum  = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(arrayBufferNew, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(cFlag[<span class="number">0</span>],sID[<span class="number">0</span>],nNum[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上我们就完成了一条协议数据的读取。</p>
<h2 id="字符串和arrayBuffer的转换">字符串和arrayBuffer的转换</h2><p>如何快速对字符串和arrayBuffer进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params">buf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(str.length * <span class="number">2</span>); <span class="comment">// 2 bytes for each char</span></span><br><span class="line">  <span class="keyword">var</span> bufView = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class="line">    bufView[i] = str.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以将生成的arrayBuffer转成Blob对象（即二进制流），发送给后台：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = str2ab(<span class="string">'test'</span>);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([ab]);</span><br></pre></td></tr></table></figure></p>
<p>当然，一般我们在做websocket通讯时还会对数据进行加密，我自己目前也正深陷加密的无底洞中……等从洞里爬出来再总结一下加密相关的内容……</p>
</div></article></div></section><footer><div class="paginator"><a class="prev"> </a><a href="/2015/12/20/20151220_rem/" class="next">下一篇</a></div><div data-thread-key="2015/12/21/20151221_typearray/" data-title="初识arrayBuffer和typeArray" data-url="http://www.shihua.im/2015/12/21/20151221_typearray/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"shihua"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?97a139550523c2b9972a6f6f339bb382";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>