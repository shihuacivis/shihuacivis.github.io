<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TypeArray、ArrayBuffer、Blob的相互转换 · shihuacivis' life</title><meta name="description" content="
Blob是现代浏览器中提供的能够装载二进制流（文件）的容器对象。
ArrayBuffer是能够装载Blob（二进制流）数据的原始缓冲区，ArrayBuffer不能直接通过js读写。
TypeArray是ArrayBuffer的一种类数组的视图对象，可以将ArrayBuffer按不同字节数读取成类似数组形式的数据类型，从而可以向读写数组元素一样，实现对ArrayBuffer数据的读写。常见的TypeArray包括Uint8Array,Uint16Array,Uint32Array等。点这里查看所有的TypedArray

所以我对"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/utakata.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/author.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="http://weibo.com/shihuacivis" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="http://shihuacivis.lofter.com" target="_blank" class="nav-list-link">LOFTER</a></li><li class="nav-list-item"><a href="https://github.com/shihuacivis" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">TypeArray、ArrayBuffer、Blob的相互转换</h1><div class="post-meta"><div class="post-time">Dec 29, 2015</div></div><div class="post-content"><ul>
<li><code>Blob</code>是现代浏览器中提供的能够装载二进制流（文件）的容器对象。</li>
<li><code>ArrayBuffer</code>是能够装载<code>Blob</code>（二进制流）数据的原始缓冲区，<code>ArrayBuffer</code>不能直接通过js读写。</li>
<li><code>TypeArray</code>是<code>ArrayBuffer</code>的一种类数组的视图对象，可以将<code>ArrayBuffer</code>按不同字节数读取成类似数组形式的数据类型，从而可以向读写数组元素一样，实现对<code>ArrayBuffer</code>数据的读写。常见的<code>TypeArray</code>包括<code>Uint8Array</code>,<code>Uint16Array</code>,<code>Uint32Array</code>等。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="external">点这里查看所有的TypedArray</a></li>
</ul>
<p>所以我对三者的理解是： <code>Blob</code> &lt;-&gt; <code>ArrayBuffer</code> &lt;-&gt; <code>TypeArray</code> &lt;—-&gt; <code>Array</code><br>由于<code>TypeArray</code>和<code>Array</code>有些相似，因此往往我会选择在<code>TypeArray</code>这层做处理。<br>下面是<code>TypeArray</code>、<code>ArrayBuffer</code>和<code>Blob</code>之间相互转换的方法。</p>
<a id="more"></a>
<h2 id="Blob_to_ArrayBuffer_（二进制流转ArrayBuffer）">Blob to ArrayBuffer （二进制流转ArrayBuffer）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* websocket的情况下二进制流的获取 */</span></span><br><span class="line"><span class="keyword">var</span> svip = <span class="string">'websocket'</span>;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(svip);</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> message = e.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = message;</span><br><span class="line"><span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">fileReader.onload  = <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">  arrayBuffer = <span class="keyword">this</span>.result; <span class="comment">// arrayBuffer即为blob对应的arrayBuffer</span></span><br><span class="line">&#125;;</span><br><span class="line">fileReader.readAsArrayBuffer(message);</span><br></pre></td></tr></table></figure>
<h2 id="ArrayBuffer_to_Blob_（ArrayBuffer转Blob）">ArrayBuffer to Blob （ArrayBuffer转Blob）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([ab]); <span class="comment">// 注意必须包裹[]</span></span><br></pre></td></tr></table></figure>
<h2 id="ArrayBuffer_to_Uint8_（ArrayBuffer转Uint8数组）">ArrayBuffer to Uint8 （ArrayBuffer转Uint8数组）</h2><p>Uint8数组可以直观的看到ArrayBuffer中每个字节（1字节 == 8位）的值。一般我们要将ArrayBuffer转成Uint类型数组后才能对其中的字节进行存取操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = arrayBuffer; <span class="comment">// arrayBuffer为要转换的值</span></span><br><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br></pre></td></tr></table></figure>
<h2 id="Uint8_to_ArrayBuffer（Uint数组转ArrayBuffer）">Uint8 to ArrayBuffer（Uint数组转ArrayBuffer）</h2><p>我们Uint8数组可以直观的看到ArrayBuffer中每个字节（1字节 == 8位）的值。一般我们要将ArrayBuffer转成Uint类型数组后才能对其中的字节进行存取操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>();</span><br><span class="line"><span class="keyword">var</span> ab = u8.buffer; <span class="comment">// ab即是u8对应的arrayBuffer</span></span><br></pre></td></tr></table></figure>
<h2 id="Array_to_ArrayBuffer（普通数组转ArrayBuffer）">Array to ArrayBuffer（普通数组转ArrayBuffer）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0x15</span>,<span class="number">0xFF</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x34</span>,<span class="number">0xAB</span>,<span class="number">0x11</span>];</span><br><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arr);</span><br><span class="line"><span class="keyword">var</span> ab = u8.buffer;</span><br><span class="line"><span class="built_in">console</span>.log(ab); <span class="comment">// ab为要解析的ArrayBuffer</span></span><br></pre></td></tr></table></figure>
<h2 id="获取/设置ArrayBuffer对应的数值">获取/设置ArrayBuffer对应的数值</h2><p>一串ArrayBuffer是可以被“理解”为很多个值的，以下面这个值为例，</p>
<p>按照服务端的协议，这串数据流的格式如下：<br>1 unsign byte (1字节) + 1 unsign int (4字节) + 1 unsign short (2字节)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x03</span>];</span><br><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arr);</span><br><span class="line"><span class="keyword">var</span> ab = u8.buffer;</span><br><span class="line"><span class="built_in">console</span>.log(ab); <span class="comment">// ab为要解析的ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// (arraybuffer, 字节解析的起点, 解析的长度)</span></span><br><span class="line"><span class="keyword">var</span> val_byte = u8[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(val_byte);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析unsign int</span></span><br><span class="line"><span class="comment">// 由于Uint32Array的解析起点必须是4的整数倍，而在流中该数据的起点是1，所以选择先“裁剪”(slice)出要解析的流片段，再用Uint32去解析该片段</span></span><br><span class="line"><span class="keyword">var</span> u32buff = ab.slice(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(u32buff);</span><br><span class="line"><span class="keyword">var</span> val_uint = u32[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(val_uint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析unsign short</span></span><br><span class="line"><span class="keyword">var</span> u16buff = ab.slice(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> u16 = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(u16buff);</span><br><span class="line"><span class="keyword">var</span> val_short = u16[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(val_short);</span><br></pre></td></tr></table></figure>
<h2 id="TypeArray_to_Array">TypeArray to Array</h2><p>在上文中可以看到，普通数组可以轻松的转换成TypeArray。<br>但TypeArray并不是Array的子集，所以它没有Array的许多方法，比如<code>push</code><br>TypeArray的方法参见：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="external">TypedArray的方法</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x03</span>];</span><br><span class="line"><span class="keyword">var</span> u8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u8.push);</span><br></pre></td></tr></table></figure>
<p>所以需要进行转换。<br>TypeArray to Array的方法,在ES6中可以用Array.form实现 （<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="external">什么是Array.form</a>）</p>
<p>也可以比较简单的封装一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Uint8Array2Array</span>(<span class="params">u8a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; u8a.length; i++) &#123;</span><br><span class="line">		arr.push(u8a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></section><footer><div class="paginator"><a href="/2015/12/29/20151229_aes/" class="prev">上一篇</a><a href="/2015/12/21/20151221_typearray/" class="next">下一篇</a></div><div data-thread-key="2015/12/29/20151229_arrayBuffer/" data-title="TypeArray、ArrayBuffer、Blob的相互转换" data-url="http://www.shihua.im/2015/12/29/20151229_arrayBuffer/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"shihuacivis"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></footer><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?97a139550523c2b9972a6f6f339bb382";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>