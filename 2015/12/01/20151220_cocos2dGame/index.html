<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用cocos2d-js-lite快速开发H5游戏 · wah's life</title><meta name="description" content="用cocos2d-js-lite快速开发H5游戏 - 石华"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://shiwah.me/atom.xml" title="wah's life"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/author.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://weibo.com/shihuacivis" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="http://shihuacivis.lofter.com" target="_blank" class="nav-list-link">LOFTER</a></li><li class="nav-list-item"><a href="https://github.com/shihuacivis" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">用cocos2d-js-lite快速开发H5游戏</h1><div class="post-info">Dec 1, 2015</div><div class="post-content"><p>cocos2d-js-lite是一个cocos2d的轻量化精简版本，只保留了cocos2d-js的一些核心方法。<br>它所包含的特性列表如下：</p>
<pre><code>+ Canvas渲染器 (不支持WebGL)
+ 场景和图层
+ 事件管理器
+ 计时器
+ 精灵和贴图
+ TTF文本
+ 声音
+ 动作
+ 菜单和菜单项
</code></pre><p>与cocos2d-js完整版一个最大的不同就是，lite版把引擎的所有模块都放到一个文件里，，开发者只需像引入一个jQuery库一样引入一个文件即可。<strong>另外，lite是基于纯原生js编写，所以无须像<code>白鹭引擎</code>（基于Typescript）要先经过编译才能在浏览器中打开，因此在开发体验上感觉与传统前端开发更为接近。</strong></p>
<a id="more"></a>
<p>从lite版包含的特性来看，它更适合开发轻度的H5游戏。</p>
<h2 id="为何要用cocos2d-js-lite"><a href="#为何要用cocos2d-js-lite" class="headerlink" title="为何要用cocos2d-js-lite"></a>为何要用cocos2d-js-lite</h2><p>在不使用游戏引擎的前提下，也可以用纯原生js + canvas + div + css制作出一款H5游戏。<br>所以所以要明白用这个游戏引擎能给我们带来什么好处。由此来决定我们需不需要它。</p>
<p>cocos下面几个特性可以提升游戏的开发进度和质量。</p>
<blockquote>
<ol>
<li>提供了资源预加载的方法，可以加载多种资源</li>
<li>可以非常简单的制作各种位移、拉伸、旋转等动画</li>
<li>提供了事件的监听和管理</li>
<li>提供了强大无脑的屏幕自适应方案</li>
<li>提供了高性能的声音及音效的播放功能</li>
<li>引擎仅300kb，对于H5应用可以接受</li>
</ol>
</blockquote>
<h2 id="cocos2d的世界中的元素"><a href="#cocos2d的世界中的元素" class="headerlink" title="cocos2d的世界中的元素"></a>cocos2d的世界中的元素</h2><p><strong>好戏开场了</strong></p>
<p>在制作游戏时，我们主要会用到下面四层元素：</p>
<blockquote>
<p>view：可以看作是一个视窗，即游戏内容的载体（可以比作舞台）。<br>Scene：舞台中一级容器就是场景。<br>Layer：场景中又可以分成很多『层』。<br>Sprite：每一个层中又可以包含很多个小的元素(如舞台上的角色）。</p>
</blockquote>
<p>跟HTML中的div盒模型做类比，以上元素的对应关系大致如下：</p>
<blockquote>
<p>view —— document、window<br>Scene —— html<br>Layer —— body<br>Sprite —— div、p等</p>
</blockquote>
<h2 id="引擎的游戏入口"><a href="#引擎的游戏入口" class="headerlink" title="引擎的游戏入口"></a>引擎的游戏入口</h2><h2 id="1-如何启动引擎"><a href="#1-如何启动引擎" class="headerlink" title="1.如何启动引擎"></a>1.如何启动引擎</h2><p>lite版本中启动引擎的方法非常简单，只需像引入jquery一样在html中引入’cocos2d-js-v3.7-lite.js’文件即可。<br>然后在在body中加入一个canvas元素，然后在游戏配置文件（即根目录下的project.json）的<code>id</code>字段中填入该canvas的id即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"cocos2d-js-v3.7-lite.js"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"gameCanvas"</span> <span class="attr">width</span>=<span class="string">"750"</span> <span class="attr">height</span>=<span class="string">"1334"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="2-如何开启游戏"><a href="#2-如何开启游戏" class="headerlink" title="2.如何开启游戏"></a>2.如何开启游戏</h2><p>首先看看游戏配置文件（即根目录下的project.json）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"debugMode"</span>     : <span class="number">1</span>,</div><div class="line">    <span class="string">"frameRate"</span>     : <span class="number">60</span>,</div><div class="line">    <span class="string">"id"</span>            : <span class="string">"gameCanvas"</span>,</div><div class="line">    <span class="string">"renderMode"</span>    : <span class="number">1</span>,</div><div class="line">    <span class="string">"showFPS"</span>       : <span class="literal">true</span>,</div><div class="line">    <span class="string">"jsList"</span>        : [</div><div class="line">      <span class="string">"j/GameScene.js"</span></div><div class="line">    , <span class="string">"j/StartScene.js"</span></div><div class="line">    , <span class="string">"j/GameControler.js"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以在该文件中设置调试模式、帧数、渲染模式、是否显示FPS信息等等。</p>
<p>可以看demo中的index.html,当游戏引擎文件加载完毕时，会触发window.onload事件，然后我们就可以通过run方法来启动游戏了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">cc.game.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当游戏开始run后，它首先根游戏的配置文件进行初始化设置调试魔术、帧数、渲染模式等，然后加载配置文件的「jsList」中的js文件。一般这些js文件就是游戏的各个模块。<br>当这些js文件都加载完毕后，就会触发一个cc.game.onStart事件，这时候游戏就算启动完毕了。<br>当然，当游戏onStart完毕后，引擎只是提供了一块随时待命的舞台（即canvas），我们还需要自己去做一些适配、资源加载等准备工作，最后再进入游戏的初始场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cc.game.onStart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 检测浏览器环境，如果是ios下则启动retina模式，有助于增强引擎渲染效果（可选项）</span></div><div class="line">  <span class="keyword">if</span> (cc.sys.IOS || cc.sys.OS_OSX) &#123;</div><div class="line">    cc.view.enableRetina(<span class="literal">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 设置游戏的预设大小（即设计稿大小）和适配方案</span></div><div class="line">  cc.view.setDesignResolutionSize(<span class="number">750</span>, <span class="number">1334</span>, cc.ResolutionPolicy.EXACT_FIT);</div><div class="line">  <span class="comment">// 让游戏随着浏览器屏幕大小伸缩变化</span></div><div class="line">  cc.view.resizeWithBrowserSize(<span class="literal">true</span>);</div><div class="line">  <span class="comment">//加载静态资源，包括图片、声音、字体等资源，res_list是一个包含资源路径的数组</span></div><div class="line">  cc.LoaderScene.preload(res_list, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </div><div class="line">      cc.director.runScene(<span class="keyword">new</span> GameScene());</div><div class="line">  &#125;, <span class="keyword">this</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="自适应方案"><a href="#自适应方案" class="headerlink" title="自适应方案"></a>自适应方案</h2><p>引擎提供了屏幕的五种适配方案，我们只需要设置好游戏预设的大小（即设计稿的大小）以及<a href="http://http://www.cocos2d-x.org/docs/manual/framework/html5/v2/resolution-policy-design/zh" target="_blank" rel="external">适配的方案</a>, 引擎就会自动完成游戏适配工作。<br>与此同时，我们在游戏中对元素的布局可以完全根据设计稿来1：1的制作，而再也不用自己费心去做适配的计算和处理啦！<br>比如这个游戏的设计稿是iphone6的屏幕大小，然后我选用的适配方案是全拉伸到覆盖屏幕的全部区域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc.view.setDesignResolutionSize(<span class="number">750</span>, <span class="number">1334</span>, cc.ResolutionPolicy.EXACT_FIT);</div></pre></td></tr></table></figure></p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>引擎自带了一个预加载模块（页面），只需要调用cc.LoaderScene.preload即可。</p>
<p>但是这个preload的界面默认会有cocos2d的logo呀，这样似乎不太好看呀。<br>这时候我们可以打开引擎的源文件，然后搜索<code>_loaderImage</code>，把这个图片（base64格式）替换成自己的图片。<br>同理，还可以将preload加载时显示的文字和其它属性进行修改。这里不多做扩展。</p>
<p><strong>当然也可以通过cc.Loader.load方法完全自定义一个加载模块</strong></p>
<p>当资源加载完毕后，我们可以调用cc.director.runScene()进入某以个场景，如上面代码中的GameScene。</p>
<h2 id="游戏场景-Scene"><a href="#游戏场景-Scene" class="headerlink" title="游戏场景 Scene"></a>游戏场景 Scene</h2><p>在开启一个场景(Scene)前,我们要先定义它，首先用cc.Scene.extend方法返回一个Scene对象，<br>这里的entend类似java等oop语言中的<code>继承</code>的概念……<br>简单的说就是通过这个方法，新生成的这个类就具备了跟<code>原始类</code>（cc.Scene）的属性和方法。同时我们可以对原始类中定义书属性和方法进行<code>重写</code>。<br>比如下面的代码中，我们对onEnter方法进行了重写。<br>onEnter是Scene的入口方法，当我们new一个Scene时会首先进入这个方法（类似Java中的Main）。通常我习惯在这个时候对将Layer元素插入到Scene中。</p>
<p>但要注意这里不能省去调用this._super()方法，这个方法的含义是去继承父类的<code>构造函数</code>（即cc.Scene的构造函数），将GameScene类<code>实例化</code>，当我们把类实例化之后，才能愉快的调用（访问）它的各个方法和变量。</p>
<p>简单的说，在进入场景时，我们要先初始化场景，调用this._super(),然后再进行其它操作。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GameScene = cc.Scene.extend(&#123;</div><div class="line">  <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._super();</div><div class="line">&#125;）</div></pre></td></tr></table></figure>
<h2 id="场景分层-Layer"><a href="#场景分层-Layer" class="headerlink" title="场景分层 Layer"></a>场景分层 Layer</h2><p>Scene的下一层容器即为Layer，当然，Scene也可以直接插入Sprite元素。<br><strong>实际上cocos2d中这些元素都只是一个虚构的概念，从属关系并没有这么严格，除了scene必须作为第一层容器之外，sprite<br>、layer等层级都没有严格的规定，</strong></p>
<p>比如sprite可以直接插入到一个Scene中，而Sprite也可以插入到另一个Sprite中。</p>
<p>Layer和Sprite也有一定的区别：</p>
<blockquote>
<ol>
<li>Layer容器默认大小是全屏（即一个全空的Layer默认和屏幕一样大），而Sprite默认大小为0x0。</li>
<li>Layer容器的的锚点默认在容器的左下角，而Sprite的锚点则在的中点（水平和垂直的中点）</li>
</ol>
</blockquote>
<p>这里讲到一个<code>锚点</code>的概念，实际上就是元素布局对齐时的基准点。<br>说到基准点，首先回到HTML和CSS的世界的定位系统，当我们用 <code>绝对定位 + left + top</code> 的组合对div进行定位时，div的锚点（基准点）就是div的左上角啦，而整个世界的定位的坐标系的出发点就是视窗的左上角，这时候我们所定义的left和top值就是div的左上角相对于视窗左上角的距离了。所以按前端习惯的工作流，我们在切设计稿时所测量的距离一般都是元素跟设计稿左上角的距离。</p>
<p>那么回到cocos的世界，不得不说，cocos的定位系统就是很反前端的，首先这个世界的坐标系默认出发点是左下角，也就是说，当我们要对元素进行布局时，默认的参考点就变成设计稿的左下角了。其次，更坑爹的是，当元素是Sprite时，你要量的距离不是设计稿左下角到元素左下角的距离，而是到元素中点的距离。<br>由于这个锚点会影响到元素的运动和裁切等功能，所以这个设定可能会让习惯了HTML世界开发的前端感到难以接受……</p>
<p>纯天然的Layer默认是透明的，当我们想创建一个带颜色的Layer时，可以继承一个Layer的派生类LayerColor，这样就可以生生成一个带背景色的Layer了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bg = <span class="keyword">new</span> cc.LayerColor(cc.color(<span class="number">42</span>, <span class="number">89</span>, <span class="number">132</span>));</div><div class="line">bg.setContentSize(<span class="number">100</span>,<span class="number">200</span>);</div><div class="line">bg.setPosition(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">this</span>.addChild(bg);</div></pre></td></tr></table></figure></p>
<p>另外提一下cc.color这个方法，它可以返回一个cocos中默认的颜色数据，所以你用RGB的值（<code>cc.color(R, G, B)</code>）或者十六进制的形式（<code>cc.color(#000000)</code>）都可以生成颜色，非常方便。<br>此外cocos还提供了类似的一些方法，都会返回cocos默认的数据格式，比如：</p>
<pre><code>1. cc.p() 返回元素定位数据
2. cc.size() 返回元素大小数据
3. cc.rect() 返回要一个矩形选区的数据（类似ps中的选区概念）
</code></pre><h2 id="精灵元素-Sprite"><a href="#精灵元素-Sprite" class="headerlink" title="精灵元素 Sprite"></a>精灵元素 Sprite</h2><p>精灵就是游戏中最基本的元素了，常用的精灵包括Sprite（显示图片）、LabelTTF（显示图片）、和MenuItemSprite（显示按钮）。</p>
<h3 id="生成Sprite"><a href="#生成Sprite" class="headerlink" title="生成Sprite"></a>生成Sprite</h3><p>Sprite生成的方法跟Layer类似，我们在create方法中传入图片的路径，即可得到该图片相对应的Sprite。<br>注意到create方法中的第二个参数rect，可以有cc.rect(x, y, width,height)获得，rect是一个矩形选区的概念，如果传入该值，那么引擎就会从传入的图片中截取选中区域的图片。<br>因此，雪碧图在游戏开发时非常好用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.hand = cc.Sprite.create(oRes[<span class="string">'hand'</span>][<span class="string">'src'</span>], rect);</div><div class="line"><span class="keyword">this</span>.hand.setPosition(size.width / <span class="number">2</span> + <span class="number">100</span>, oRes[<span class="string">'hand'</span>][<span class="string">'height'</span>] / <span class="number">2</span>);</div><div class="line"><span class="keyword">this</span>.addChild(<span class="keyword">this</span>.hand);</div></pre></td></tr></table></figure></p>
<h3 id="生成LabelTTF"><a href="#生成LabelTTF" class="headerlink" title="生成LabelTTF"></a>生成LabelTTF</h3><p>LabelTTF似乎已经是lite版本中动态显示图片的唯一方案了，在生成一个LabelTTF对象时，我们可以指定它的内容、所用的字体（ttf格式的字体或者系统自带字体）、字体大小、元素所占区域大小、对齐方式等等）;<br>然后我们可以通过getString方法和setString获取、设置label的内容；<br>还可以通过setColor设置文字的颜色。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.lbMoney = cc.LabelTTF.create(<span class="string">'0'</span>, <span class="string">'Arial'</span>, <span class="number">64</span>, cc.size(<span class="number">200</span>, <span class="number">64</span>), cc.TEXT_ALIGNMENT_RIGHT);</div><div class="line"><span class="keyword">this</span>.lbMoney.setPosition(size.width / <span class="number">2</span>  + <span class="number">50</span>, size.height / <span class="number">2</span> + <span class="number">455</span>);</div><div class="line"><span class="keyword">this</span>.lbMoney.setColor(cc.color(<span class="string">'#2a5984'</span>))</div><div class="line"><span class="keyword">this</span>.addChild(<span class="keyword">this</span>.lbMoney, <span class="number">1</span>);</div><div class="line"><span class="keyword">this</span>.lbMoney.setString(nData);</div></pre></td></tr></table></figure></p>
<h2 id="生成按钮"><a href="#生成按钮" class="headerlink" title="生成按钮"></a>生成按钮</h2><p>由于引擎基于canvas绘制，所以绘制的元素就不能逐一的绑定通常我们所认知的click、hover等这些html世界中的事件。<br>所以按钮似乎是cocos世界里唯一可以个简单的一对一绑定点击事件的方法了。<br>在cocos中按钮又叫菜单，它的结构必须是这样的 菜单（menu） -》 菜单项（menuItem）<br>因此我们首先要生成1个和多个menuItem，然后再把它（们）添加到menu（类似于Layer）中，这样每个menuItem才能发挥作用。<br>首先在创建item时，item分为两种方法：</p>
<ol>
<li><p>MenuItemSprite</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sp1 = cc.Sprite.create(oRes1[<span class="string">'src'</span>], rect1);</div><div class="line"><span class="keyword">var</span> sp2 = cc.Sprite.create(oRes2[<span class="string">'src'</span>], rect2);</div><div class="line"><span class="keyword">var</span> mis = cc.MenuItemSprite.create(sp1, sp2, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	</div><div class="line">&#125;, <span class="keyword">this</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>MenuItemImage</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oRes = sResName;</div><div class="line"><span class="keyword">var</span> mii = cc.MenuItemImage.create(oRes[<span class="string">'src'</span>], oRes[<span class="string">'src'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以机智的你一定知道怎样做文字的按钮啦，两个LabelTTF完事：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sp1 = cc.LabelTTF.create(<span class="string">'start'</span>, <span class="string">'Arial'</span>, <span class="number">64</span>, cc.size(<span class="number">100</span>, <span class="number">64</span>), cc.TEXT_ALIGNMENT_RIGHT);</div><div class="line">sp2 = cc.LabelTTF.create(<span class="string">'start'</span>, <span class="string">'Arial'</span>, <span class="number">64</span>, cc.size(<span class="number">100</span>, <span class="number">64</span>), cc.TEXT_ALIGNMENT_RIGHT);</div><div class="line"><span class="keyword">var</span> mi = cc.MenuItemSprite.create(sp1, sp2, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1111</span>);</div><div class="line">&#125;, <span class="keyword">this</span>);</div><div class="line"><span class="keyword">var</span> me = cc.Menu.create(mi);</div></pre></td></tr></table></figure></p>
<h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><p>cocos中的动作是引擎的一大优势，用起来非常简单，以位移动作为例：<br>以cc.moveBy方法可以创建一个相对位移的动作，比如这样先相对Y轴唯一40px;<br>然后FadeIn和FadeOut顾名思义是淡入淡出的动作。<br>然后注意到spawn方法，这个返回的是多个动作同时执行的效果。<br>而Sequence方法则可以返回多个动作按顺序依次执行的效果。</p>
<p>当想要在某些动作之后想执行某个方法时，可以用cc.callFunc生成一个callback对象，加入到sequenece对象中即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m0 = cc.FadeIn.create(<span class="number">0.3</span>);</div><div class="line"><span class="keyword">var</span> m1 = cc.moveBy(<span class="number">.3</span>, cc.p(<span class="number">0</span>,<span class="number">40</span>));</div><div class="line"><span class="keyword">var</span> m2 = cc.moveBy(<span class="number">.3</span>, cc.p(<span class="number">0</span>, <span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> m3 = cc.FadeOut.create(<span class="number">0.7</span>);</div><div class="line"><span class="keyword">var</span> m4 = cc.Spawn.create(m0, m1);</div><div class="line"><span class="keyword">var</span> m5 = cc.Spawn.create(m2, m3);</div><div class="line"><span class="keyword">var</span> m6 = cc.moveBy(<span class="number">.3</span>, cc.p(<span class="number">0</span>, <span class="number">-50</span>));</div><div class="line"><span class="keyword">var</span> callback = <span class="keyword">new</span> cc.CallFunc(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// todo</span></div><div class="line">&#125;, self);</div><div class="line"><span class="keyword">var</span> m = cc.Sequence.create(m4, m5, m6, callback);</div></pre></td></tr></table></figure>
<h2 id="事件监听和碰撞检测"><a href="#事件监听和碰撞检测" class="headerlink" title="事件监听和碰撞检测"></a>事件监听和碰撞检测</h2><p>前面提到过，游戏中事件监听很难单独对某个元素绑定事件，所以得转变一下思路。<br>当我们要监听某些元素的touch等一系列事件时，<br>首先我们可以监听到的是整个窗口的touchbegan、onTouchesMoved、onTouchesEnded等事件，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">cc.eventManager.addListener(&#123;</div><div class="line">  <span class="attr">event</span>: cc.EventListener.TOUCH_ONE_BY_ONE</div><div class="line">, <span class="attr">swallowTouches</span>: <span class="literal">true</span></div><div class="line">, <span class="attr">onTouchBegan</span>: <span class="function"><span class="keyword">function</span>(<span class="params">touch, event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> location = touch.getLocation();</div><div class="line">    <span class="keyword">var</span> oRealLc = self.convertToNodeSpace(location);</div><div class="line">    <span class="keyword">var</span> _x = oRealLc.x;</div><div class="line">    <span class="keyword">var</span> _y = oRealLc.y;</div><div class="line">    <span class="comment">// sth to do</span></div><div class="line">  &#125;</div><div class="line">&#125;, <span class="keyword">this</span>);</div><div class="line">cc.eventManager.addListener(&#123;</div><div class="line">  <span class="attr">prevTouchId</span>: <span class="number">-1</span></div><div class="line">, <span class="attr">swallowTouches</span>: <span class="literal">true</span></div><div class="line">, <span class="attr">event</span>: cc.EventListener.TOUCH_ALL_AT_ONCE</div><div class="line">, <span class="attr">onTouchesMoved</span>:<span class="function"><span class="keyword">function</span> (<span class="params">touches, event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> touch = touches[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> location = touch.getLocation();</div><div class="line">    <span class="keyword">var</span> oRealLc = self.convertToNodeSpace(location);</div><div class="line">    <span class="keyword">var</span> _x = oRealLc.x;</div><div class="line">    <span class="keyword">var</span> _y = oRealLc.y;</div><div class="line">    <span class="comment">// sth to do</span></div><div class="line">  &#125;</div><div class="line">, <span class="attr">onTouchesEnded</span>: <span class="function"><span class="keyword">function</span>(<span class="params">touches, event</span>)</span>&#123;</div><div class="line">    <span class="comment">// sth to do</span></div><div class="line">  &#125;</div><div class="line">&#125;, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>然后我们可以判断事件的触发点是否在我们要绑定的元素上。<br>所以问题就变成了，如何判断某个坐标点是否在某个元素显示的区域上，<br>这个问题其实和检测两个元素是否发生碰撞类似，都会用到一个rectContainsPoint的方法，首先用cc.rect获取要判断的元素的矩形选中区域，然后oPoint为事件触发的坐标点，那么这个方法即可返回oPoint是否再oRect中了（上面的代码中中convertToNodeSpace可以将坐标点转化成指定元素为基准的坐标点）;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oRect = cc.rect(startX, startY, w, h);</div><div class="line"><span class="keyword">var</span> oPoint = cc.p(_x, _y);</div><div class="line">cc.rectContainsPoint(oRect, oPoint)</div></pre></td></tr></table></figure>
<h2 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h2><p>传入参数：声音url、是否循环<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cc.audioEngine.playEffect(sSoundUrl, <span class="literal">false</span>);</div><div class="line">cc.audioEngine.playMusic(sSoundUrl, <span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器也是cocos中一个非常方便的功能，当然也可以用其它方法实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cc.director.getScheduler().scheduleCallbackForTarget(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// sth to do</span></div><div class="line">&#125;, <span class="number">1</span>, <span class="number">0</span> , <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<h2 id="简单总结优缺点"><a href="#简单总结优缺点" class="headerlink" title="简单总结优缺点"></a>简单总结优缺点</h2><p><em>首先要吐槽一下lite版本不支持的2个实用功能</em></p>
<blockquote>
<ol>
<li>不支持位图字体labelBMFont方法</li>
<li>不支持从plist生成元素（当然传统前端并不知道这有啥用）</li>
</ol>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ol>
<li>框架轻巧，适合web方向的游戏开发</li>
<li>系统功能完善，提供了预加载、截取雪碧图、绘图、动画、事件监听管理、定时器等调用方法非常简单的方法</li>
</ol>
</blockquote>
<p>很多缺点都是见仁见智的，这里我只举几个我认为比较硬伤的问题。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ol>
<li><p>引擎将需要引入的js文件罗列在一个project.json的文件中，而这个json文件是在引擎启动后再通过XHR加载的，加之引擎本身的版本号管理功能不是很完善，很容易由于现代浏览器强力的缓存机制而造成项目文件不易更替。因此不适合用在需要经常变更版本或代码的游戏上，当然这点可以通过修改引擎源码解决。</p>
</li>
<li><p>引擎的预加载方法没有提供回调，当资源加载失败时不能很好的做一些补救措施。举一个实际碰到的问题：在我们的项目中用到了CDN的加速方案，这时候图片其实都是访问CDN获取的，但是由于<strong>某些坑爹的网络提供商的流氓拦截</strong>、<strong>用户使用了某些网络加速器</strong>、<strong>CDN有万分之几的访问失败几率</strong>造成CDN上的图片资源不能正常加载，这个时候引擎就有可能会报错了。而实际上这时候我们更希望引擎能够做一些<code>回源</code>的处理，访问源服务器上的资源，这样出错而造成游戏不能玩的几率可能会大大降低。当然这点也可以通过修改引擎解决……</p>
</li>
<li><p>自适应方案看上去很厉害，但是在一些特殊运用时还是不尽如人意，比如想在竖屏环境下自动将横版游戏旋转过来，就不是很好做，通过自适应方案得出来的结果也会怪怪的。感兴趣的可以自己试试。</p>
</li>
<li><p>声音加载时在安卓手机上有bug，会在加载时把音效播放出来……</p>
</li>
</ol>
</blockquote>
<h3 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h3><p><strong><em> <a href="https://github.com/shihuacivis/gameCountMoney" target="_blank" rel="external">DEMO的github地址</a> </em></strong></p>
<p><strong>未完待续</strong></p>
</div></article></div></main><footer><div class="paginator"><a href="/2015/12/20/20151220_rem/" class="prev">PREV</a><a href="/2015/11/18/20150918_codeBeter/" class="next">NEXT</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "73fc09c4a9074b41b145fb564eada364",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script><div class="copyright"><p>© 2015 - 2017 <a href="http://shiwah.me">石华</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>