<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 获取TouchEvent准确的Target · wah's life</title><meta name="description" content="获取TouchEvent准确的Target - 石华"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://shiwah.me/atom.xml" title="wah's life"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/author.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://weibo.com/shihuacivis" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/shihuacivis" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">获取TouchEvent准确的Target</h1><div class="post-info">Aug 24, 2017</div><div class="post-content"><p>细心朋友可能已经发现了，我们在处理<code>touchmove</code>、<code>touchend</code>事件时，通过<code>event.target</code>属性获取的永远等于<code>touchstart</code>起始触发的元素。<br>也就是说当我们从A元素开始触屏，即使我们现在划到B元素上，<code>event.target</code>返回的还是A。<br>这个表现与<code>mousemove</code>事件的表现不一致。<br>可以通过下列方法获得事件真实的target。</p>
<a id="more"></a>
<h2 id="document-elementFromPoint"><a href="#document-elementFromPoint" class="headerlink" title="document.elementFromPoint"></a>document.elementFromPoint</h2><p>首先可以获取事件触发时的坐标点，通过<code>document.elementFromPoint</code>方法获取当前点对应的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> params = &#123;<span class="attr">clientX</span>: <span class="number">0</span>, <span class="attr">clientX</span>: <span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">let</span> clientX = e.touches[<span class="number">0</span>].clientX;</div><div class="line"><span class="keyword">let</span> clientY = e.touches[<span class="number">0</span>].clientY;</div><div class="line">params = &#123;clientX, clientY&#125;;</div><div class="line"><span class="keyword">let</span> $target = <span class="built_in">document</span>.elementFromPoint(params.clientX, params.clientY);</div></pre></td></tr></table></figure>
<h2 id="判断元素的子孙关系（parentNode、childNodes、isEqualNode）"><a href="#判断元素的子孙关系（parentNode、childNodes、isEqualNode）" class="headerlink" title="判断元素的子孙关系（parentNode、childNodes、isEqualNode）"></a>判断元素的子孙关系（parentNode、childNodes、isEqualNode）</h2><p>上述方法获取元素会带来一个问题。<br>比如：页面元素的从属关系是A-&gt;B-&gt;C,当我们点击B元素的子元素C，我们获得的target是C。<br>那就可以遍历检测A与C的子孙关系，进一步获得我们更关心A元素和B元素的关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> el = <span class="string">'父元素A'</span></div><div class="line"><span class="keyword">let</span> index = <span class="number">-1</span>; <span class="comment">// B元素相对于A元素的索引</span></div><div class="line"><span class="keyword">let</span> aTargetEl = [];</div><div class="line"><span class="comment">// 遍历获取target元素在dom树中的路径</span></div><div class="line"><span class="keyword">while</span> ($target.tagName.toLowerCase() != <span class="string">'body'</span>) &#123;</div><div class="line">  aTargetEl.push($target);</div><div class="line">  $target = $target.parentNode;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>, len = el.childNodes.length; idx &lt; len; idx++) &#123;</div><div class="line">  <span class="keyword">let</span> child = el.childNodes[idx];</div><div class="line">  <span class="comment">// 遍历A的子元素判断是否处于target元素的dom树路径中</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = aTargetEl.length; i &lt; l; i++) &#123;</div><div class="line">    <span class="keyword">let</span> oEl = aTargetEl[i];</div><div class="line">    <span class="keyword">if</span> (child.isEqualNode(oEl)) &#123;</div><div class="line">      index = idx;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/24/20171129_contentEditable/" class="next">NEXT</a></div><div id="comments"></div><script>var gitment = new Gitment({
id: '', // optional
owner: 'shihuacivis',
repo: 'shihuacivis',
oauth: {
    client_id: 'fde0af8e5f82252f29c4',
    client_secret: '181903375a328f9f759452d4797b604acc0942ef',
},
// ...
// For more available options, check out the documentation below
})
gitment.render('comments')</script><div class="copyright"><p>© 2015 - 2017 <a href="http://shiwah.me">石华</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>